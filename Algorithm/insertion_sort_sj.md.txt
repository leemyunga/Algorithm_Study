# Insertion sort

### 삽입 정렬
#
* 삽입 정렬은 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘
* 뒤섞여 있는 트럼프 카드를 순서대로 다시 정리하는 모습을 생각하면 이해하기 쉬움. 가장 왼쪽에서부터 한 장씩 카드를 꺼내서 이미 정렬된 카드들 중에 올바른 자리에 끼워넣는 것과 같음

<br/>

### 동작 방식
#
1. 배열을 정렬된 부분과 정렬되지 않은 부분으로 나눠줌
2. 정렬되지 않은 부분에서 원소를 선택하고, 그걸 정렬된 부분에 삽입함
3. 이걸 정렬되지 않은 부분이 없을 때까지 계속 반복함

<br/>

### 예시
#
* 5 1 6 4 2 3 
* 위의 숫자들을 트럼프 카드라고 생각
1. 앞의 카드 두 장을 선택하고, 오른쪽 카드가 왼쪽 카드보다 큰 지 비교해봄
2. 왼쪽이 5, 오른쪽이 1 이니까 오른쪽이 더 작음
3. 그러면 1을 뽑아서 5를 한 자리 옮긴 뒤에 5가 이동하면서 생긴 빈자리로 1을 삽입함

* 1 5 6 4 2 3
* 정렬 대상의 범위를 늘려서 크기가 3개가 됨 (1,5,6)
1. 3개 중 마지막 요소가 6인데 바로 앞의 5랑 비교하면 6이 크니까 제자리에 있음
2. 그 이전의 요소들(1,5) 는 이미 정렬된 상태니까 건들지 않음
3. 끝났으면 다시 반복 -> 정렬 대상 4개 (1,5,6,4)
4. 마지막 요소인 4가 앞의 6보다 작으니까 4를 뽑고, 4보다 큰 수는 한 칸씩 이동함
5. 정확한 위치에 4를 삽입함 

* 1 4 5 6 2 3 
* 이걸 계속 반복해서 1 2 3 4 5 6 이 되게 해줌

<br/>



### 구현
#
```
public class InsertionSort {

    public static void main(String[] args) {
        
	// 초기값 설정
	int[] array = {5, 1, 6, 4, 2, 3};
	
	// 삽입정렬 메서드 구현
        insertionSort(array);

        for (int num : array) {
            System.out.print(num + " "); //출력
        }
    }
    
    public static void insertionSort(int[] arr) {

	// 배열 길이를 저장
        int n = arr.length;
	
	// 반복문 이용해서 정렬하는데 1부터 시작해서 끝까지 반복해줌
        for (int i = 1; i < n; i++) {

	// 선택된 현재 원소 key , i의 이전 값인 j 
            int key = arr[i];
            int j = i - 1;
            
            // while 반복문 이용, 정렬된 부분에서 key보다 큰 원소를 찾으면서 오른쪽으로 이동함
	    // j 가 0 이상이고, arr[j] 가 key 보다 큰 동안 반복할건데
	      // 현재 원소 (key)  보다 큰 원소들을 한 칸씩 오른쪽으로 이동시켜줌 
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
	    // while 반복문이 끝난 후에는 key 원소를 올바른 위치에 삽입해줌
	      // arr[j + 1] 위치에 key 값을 넣어주면 현재까지 정렬된 부분에 key가 올바른 위치에 삽입됨
            arr[j + 1] = key;
        }
    }
}


```

<br>

### 시간 복잡도
#
 삽입 정렬의 시간 복잡도는 비교 연산과 데이터의 이동에 의해 결정됨
* 최선의 경우 : 배열이 이미 정렬되어있을 때, 비교는 한 번씩만 이루어지니까 비교 횟수는 O(n)
* 최악의 경우 : 배열이 역순으로 정렬되어 있을 때 비교 횟수는 O(n^2)
* 평균적인 경우 : 평균적으로 적절한 위치로 이동시키기 위해서 비교 횟수는 O(n^2)

* Space Complexity 공간 복잡도
  * 선택 정렬의 공간 복잡도는 **O(1)**
  * 정렬을 위해 배열 외에 다른 데이터 구조를 사용하지 않기 때문에 입력 크기와 상관없이 일정한 공간만을 사용

### 공간 복잡도
#
*삽입 정렬의 공간 복잡도는 주로 배열 외에 추가적인 공간을 사용하는 경우 결정됨
* 주어진 배열 안에서 교환을 통해 정렬이 수행되니까 O(n)

<br>


### 장단점

## 장점
#
1. 작은 배열에서는 상대적으로 빠른 성능을 보임
2. 정렬된 배열에 대해서 효율적으로 처리 가능함
3. 정렬하고자 하는 배열 안에서 교환하는 방식이라 다른 메모리 공간을 필요로 하지 않는다 => 제자리 정렬
4. 안정 정렬(Stable Sort) 이다.

## 단점
#
1. 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적임
2. 배열의 크기가 커질 수록 다른 효율적인 정렬 알고리즘에 비해 느릴 수 있음

<br>

<br>
<br>

<footer>


</footer>
