# SPRING

### [Q] Spring Framework에 대해 설명해주세요.
[A] 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크 입니다.

<br>

### [Q] Spring Boot와 Spring Framework의 차이점을 설명해주세요. 
[A] 가장 큰 차이점은 Auto Configuration의 차이인 것 같습니다. Spring은 프로젝트 초기에 다양한 환경설정을 해야 하지만,
Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 도와줍니다.
spring boot starter dependency만 추가해주면 설정은 끝나고, 내장된 톰캣을 제공해 서버를 바로 실행할 수 있습니다.
<br>

### [Q] @RequestBody, @RequestParam, @ModelAttribute의 차이를 설명해주세요.
[A] 
@RequestBody 는 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할을 합니다.

값을 주입하지 않고 값을 변환 시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter,Setter가 없어도 정상적으로 할당된다.


@RequestParam 은 1개의 HTTP 요청 파라미터를 받기 위해 사용합니다. 

@RequestParam은 필수 여부가 true이기 때문에,
기본적으로 반드시 해당 파라미터가 전송되어야 합니다. 전송되지 않으면 400Error를 유발할 수 있으며,
반드시 필요한 변수가 아니라면 required의 값을 false로 설정해줘야 합니다.

@ModelAttribute 는 HTTP Body 내용과 HTTP 파라미터의 값들을 생성자,Getter,Setter를 통해 주입하기 위해 사용합니다.

값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 Getter,Setter가 없으면 변수들이 저장되지 않는다.

<br>

### [Q] Spring MVC에 대해 설명해주세요.
[A] 
MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴입니다.
Model은 데이터 관리 및 비즈니스 로직을 처리하는 부분이며, (DAO, DTO, Service 등)
View는 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간입니다. (html, jsp, tymeleaf, mustache 등 화면을 구성하기도 하고, Rest API로 서버가 구현된다면 json 응답으로 구성되기도 한다.)
Controller는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 합니다. Model과 View는 서로 연결되어 있지 않기 때문에 Controller가 사이에서 통신 매체가 되어줍니다.

<br>

### [Q] MVC는 어떠한 흐름으로 요청을 처리하는지 설명해주세요.
[A] 

DispatcherServlet : 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제한다.
HandlerMapping : 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정한다.
HandlerAdapter : HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 한다.
ViewResolver : Controller의 처리 결과(데이터)를 생성할 view를 결정한다.

1. 클라이언트는 URL을 통해 요청을 전송한다.
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.
6. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.
8. 데이터가 추가된 뷰를 반환한다.

<br>

### [Q] 제어의 역전(IoC, Inversion of Control)에 대해 아는대로 설명해주세요.
[A] 
제어의 역전(IoC)란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말합니다.
스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입(DI, Dependency Injection)하는 역할을 하고
컨테이너에 등록한 객체들을 '빈'이라고 합니다.

<br>

### [Q] 스프링에서 빈(Bean)을 등록하는 방법에 대해 말해보세요.
[A] 
1. 우선 가장 쉬운 방법으로 @Component 어노테이션을 사용하는 것입니다.
@Controller, @Service, @Repository는 모두 @Component를 포함하고 있습니다.

2. 설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고,
해당 클래스 안에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성됩니다.

<br>

### [Q] 의존성 주입(DI, Dependency Injection)에 대해 설명해주세요.
[A]  
의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것입니다.
이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있습니다.

의존성 주입은 생성자 주입, 필드 주입, 세터 주입의 3 가지 방법이 있습니다.
이 중 Spring에서 가장 권장하는 방법은 생성자를 통한 주입 방법입니다.
그 이유는 1. 순환 참조를 방지 2. 불변성을 가짐 3. 테스트에 용이하기 때문입니다.

<br>

### [Q] 관점지향 프로그래밍(AOP, Aspect Oriented Programming)는 무엇이고, 언제 사용할 수 있을까요?
[A] AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며
공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이합니다.

핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있습니다.

AOP의 가장 큰 특징이자 장점은 중복 코드 제거, 재활용성의 극대화, 변화수용의 용이성이 좋다는 점입니다.

<br>

### [Q] Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?
[A] Lombok은 메소드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만들어냅니다. 이것을 어노테이션 프로세싱이라고 하는데,
어노테이션 프로세싱은 자바 컴파일러가 컴파일 단계에서 어노테이션을 분석하고 처리하는 기법을 말합니다.
(Lombok 라이브러리를 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유도 된다.)

<br>


### [Q] 서블릿(Servlet)에 대해 설명해주세요.
[A] 
서블릿은 자바를 사용해 웹을 만들기 위해 필요한 기술입니다.
클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술입니다.
Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환합니다.

<br>

### [Q] VO와 BO, DAO, DTO에 대해 설명해주세요. 
[A] 
DAO(Data Access Object) DB의 데이터에 접근을 위한 객체를 말합니다. (Repository 또는 Mapper에 해당)
BO(Business Object) 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체를 말합니다. (Service에 해당)
DTO(Data Transfer Object) 각 계층간의 데이터 교환을 위한 객체를 말합니다. (여기서 말하는 계층은 Controller, View, Business Layer, Persistent Layer)
VO (Value Object) 실제 데이터만을 저장하는 객체를 말합니다.

<br>

### [Q] Entity 에 대해 설명해주세요 
[A] Entity 클래스는 실제 DataBase의 테이블과 1 : 1로 매핑되는 클래스로,
DB의 테이블내에 존재하는 컬럼만을 속성(필드)으로 가져야 합니다.
Entity 클래스는 상속을 받거나 구현체여서는 안되며, 테이블내에 존재하지 않는 컬럼을 가져서도 안됩니다.

최대한 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서필요한 로직 method를 구현해야하고, Domain Logic만을 가지며, Presentation Logic을 가지고 있어서는 안됩니다.

<br>

### [Q] Entity, DTO 클래스를 분리하는 이유
[A] Entity와 DTO를 분리해서 관리해야 하는 이유는 DB 와 View 사이의 역할을 철저히 분리하기 위해서 입니다.

Entity 클래스는 실제 테이블과 매핑되어 만일 변경되게 된다면 다른 클래스에 영향을 끼치고,
DTO 클래스는 View와 통신하며 자주 변경되므로 분리 해주어야 합니다. (Entity 클래스 보호)

<br>

### [Q] Spring의 싱글톤 패턴에 대해 설명해주세요.
[A] 스프링에서 bean 생성시 별다른 설정이 없으면 default로 싱글톤이 적용됩니다.
스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데,
요청이 들어올 때마다 매번 객체를 생성하지 않고, 이미 만들어진 객체를 공유하기 때문에 효율적인 사용이 가능합니다.
이를 통해 얻을 수 있는 장점은,

static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.
테스트하기 편리하다.

<br>

### [Q] Spring의 스코프 프로토 타입 빈에 대해 설명해주세요.
[A] 프로토타입 빈은 싱글톤(default bean) 빈과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새로운 객체를 생성하여 반환해줍니다.
이렇게 빈의 scope를 간단하게 관리해줄 수 있는 것이 spring의 장점입니다.
빈의 scope 설정은 @Scope 어노테이션으로 설정하며, 프로토타입 scope로 설정하려면 @Scope(”prototype”)와 같이 문자열로 지정해줍니다.


### [Q] 데이터베이스의 특징에 대해 설명해주세요.
[A] 
- 실시간 접근성(Real-Time Accessibility) : 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 하며,
- 지속적인 변화(Continuous Evloution) : 데이터베이스의 상태는 동적입니다. 즉 새로운 데이터의 삽입(Insert), 삭제(Delete), 갱신(Update)으로 항상 최신의 데이터를 유지해야 합니다.
- 동시 공용(Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 합니다.
- 내용에 의한 참조(Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾습니다.

<br>

### [Q] 데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요.
[A] 
DDL (정의어 : Data Definition Language) : 데이터베이스 구조를 정의, 수정, 삭제하는 언어 ( alter, create, drop )
DML (조작어 : Data Manipulation Language) : 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 ( select, insert, update, delete )
DCL (제어어 : Data Control Language) : 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어 ( commit, rollback, grant, revoke )

<br>


### [Q] SELECT 쿼리의 수행 순서를 알려주세요.
[A] 
FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT
1. FROM

- 각 테이블을 확인한다.

2. ON

- JOIN 조건을 확인한다.

3. JOIN

- JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.

2. WHERE

- 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.

3. GROUP BY

- WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.

4. HAVING

- GROUP BY절이 쿼리에 있을 경우 HAVING 절의 제약조건이 그룹화된 행에 적용된다.

5. SELECT

- SELECT에 표현된 식이 마지막으로 적용된다.

6. DISTINCT

- 표현된 행에서 중복된 행은 삭제

7.ORDER BY

- 지정된 데이터를 기준으로 오름차순, 내림차순 지정

8. LIMIT

- LIMIT에서 벗어나는 행들은 제외되어 출력된다.

<br>


### [Q] 트리거(Trigger)에 대해 설명해주세요.
[A]  
트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.
사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.

<br>

### [Q]  Index에 대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요.
[A] 
Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.

예를들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것이다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.

즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.

<br>

### [Q] 정규화에 대해 설명해주세요.
[A] 
하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

제1 정규형 : 테이블의 컬럼이 하나의 값을 갖도록 분해합니다.

제2 정규형: 제1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.

※ 여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미


제3 정규형 : 제2 정규형을 만족하고, 이행적 함수 종속을 없애도록 분해합니다.

※ 여기서 이행적 종속이란 A → B, B → C가 성립할 때 A → C가 성립되는 것을 의미

<br>

### [Q] 정규화에는 어떤 장점이 있고 어떤 단점이 있는지 아는대로 설명해주세요.
[A] 
장점

1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.

2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

단점

릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.

+ 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

<br>

### [Q] 역정규화를 하는 이유에 대해 아는대로 설명해주세요.
[A] 
정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로인해 성능이 저하될 우려가 있습니다.

역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위함입니다.

<br>

### [Q] 트랜잭션이란 무엇인지 설명해주세요.
[A] 
트랜잭션은 작업의 완전성을 보장해줍니다.
즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.

<br>

### [Q] 트랜잭션의 특성(ACID)에 대해 설명해주세요.
[A] 
1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.

2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.

3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.

4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.

<br>

### [Q] DB 락에 대해 설명해주세요.
[A] 
DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.
공유락(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.
베타락(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.

<br>

### [Q]  Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
[A] 
RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
(MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하긴 하지만, 한글 검색의 경우 아직 많이 빈약한 감이 있습니다.)
하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다.
※ Full-Text : 이미지, CSS, 글 등의 복합적으로 이뤄진 컨텐츠에서 순수하게 텍스트만 추출한 데이터를 의미. 이 과정을 보통 크롤링으로 구현함 ( 엘라스틱 서치의 검색엔진엔 크롤러가 빠져있어 별도로 구축해야함)

<br>

### [Q] JOIN
[A] 
JOIN 연산은 두 테이블을 결합하는 연산입니다.
데이터의 규모가 커지면서 하나의 테이블로 정보를 수용하기 어려워지면 테이블을 분할하고 테이블 간의 관계성을 부여합니다

<br>

### [Q] inner join과 outer join의 차이를 설명해주세요.
[A] 
inner join 은 서로 연관된 내용만 검색하는 조인 방법입니다.
A와 B에 대해 수행하는 것은, A와 B의 교집합을 말합니다. 벤다이어그램으로 그렸을 때 교차되는 부분입니다.

outer join 은 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법입니다.
A와 B에 대해 수행하는 것은, A와 B의 합집합을 말합니다. 벤다이어그램으로 그렸을 때 합집합 부분입니다.
outer join에는 LEFT JOIN, RIGHT JOIN이 있습니다.

<br>

### [Q] DELETE, TRUNCATE, DROP의 차이를 설명해주세요.
[A]  
DELETE는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 되돌릴 수 있습니다.

TRUNCATE는 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없습니다.

DROP은 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제 후 되돌릴 수 없습니다.

<br>

### [Q]  HAVING과 WHERE의 차이를 설명해주세요.
[A]  
having은 그룹을 필터링 하는데 사용되고, where은 개별 행을 필터링하는데 사용됩니다.

집계 함수(COUNT, SUM, AVG, MAX, MIN 등)는 having절과 함께 사용할 수 있으나,
where절은 사용할 수 없습니다.( 집계함수를 사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저 수행)

having은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,
where은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용됩니다.
<br>

### [Q] JOIN에서 ON과 WHERE의 차이를 설명해주세요.
[A]  
ON 이 WHERE 보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고 (=ON 조건으로 필터링이 된 레코들간 JOIN이 이뤄진다)
WHERE은 JOIN 을 한 후에 필터링을 합니다. (=JOIN을 한 결과에서 WHERE 조건절로 필터링이 이뤄진다)
<br>


### [Q] 동기 VS 비동기 방식
[A]  
동기방식은 설계가 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야
하는 단점이 있습니다.
비동기방식 은 동기보다는 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안
작업을 할 수 있어서 자원을 효율적으로 사용할 수 있는 장점이 있습니다.
예를 들어, 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 동기와 달리 비
동기는 서버에 데이터를 요청한 이후 응답될 때까지 대기하지 않고 즉시 다음 테스크를 계속
해 수행할 수 있습니다.
<br>

### [Q] synchronized
[A]  
여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드
를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
<br>

### [Q] 프로세스, 스레드
[A]  
프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역을 다른 프
로세스와 공유하지 않습니다. 또한, 프로세스는 최소 1개의 쓰레드를 가지고 있습니다.
쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
JAVA 8
프로세스 내에서 Stack만 따로 할당 받고, 서로 다른 쓰레드의 메모리 영역을 공유하기 때문
에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다.
<br>

### [Q] 멀티 스레드의 장점과 단점
[A] 
멀티 쓰레드는 적은 메모리 공간을 차지하고 문맥 전환이 빠르다(질문)는 장점이 있지만
하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이
있습니다.

<br>

### [Q] JDBC Java Database Connectivity
[A]  
JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미합니다.
<br>

### [Q] API Applictation Programming Interface
[A]  
다른 프로그램에 이용할 수 있도록 제공되는 클래스와 인터페이스입니다.

<br>

### [Q] RestfulAPI
[A] 
RESTfulAPI는 REST의 설계 규칙을 잘 지켜서 설계된 API를 말합니다.
<br>

### [Q] Get VS Post 방식
[A] 
GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방
식입니다.
GET 방식은 URL에 데이터가 노출이 되기 때문에 보안적으로 좋지 않습니다.
POST 방식은 데이터를 추가나 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가해
서 전송하는 방식입니다.
POST 방식은 URL에 데이터가 노출되지 않기 때문에 GET 보다는 안전한 편입니다.
대신 전송 속도가 GET 방식보다 느립니다.

<br>

### [Q] Cookie VS Session
[A] 
쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의
상태 정보를 PC에 저장했다가 필요할 때 그 정보를 참조하거나 재사용할 수 있습니다.
세션은 일정 시간동안 같은 사용자로부터 들어오는 어떤 요구들을 하나의 상태로 보고, 그
상태를 유지시키는 기술입니다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로
보고 그것을 세션이라고 합니다.
<br>

### [Q] jsp, servlet
[A] 
Servlet은 컨테이너가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것이고,
JSP(Java Server Page)는 html기반에 JAVA코드를 블록화하여 삽입한 것입니다.
<br>

### [Q] model1 과 model2 의 차이점
[A] 
Model1은 Jsp가 뷰와 컨트롤러의 역할을 모두 감당합니다.
Jsp가 두 역할을 모두 수행할 때는 소스가 복잡해지기 때문에 유지보수가 힘들어집니다.
Model2는 Model1 의 단점을 보완할 수 있는데요,
Model1 과 달리 컨트롤러의 역할은 서블릿에서 담당하고 응답처리는 JSP에서 구현됩니다.
개발속도는 비교적 느려지지만 확장과 유지보수가 수월해집니다.
<br>

### [Q] 어노테이션
[A]
인터페이스를 기반으로 한 문법으로 주석, 자바코드에 주석을 달아 특별한 의미를 부여한 것
입니다.

<br>

### [Q] 직렬화
[A]
시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이
트(byte) 형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터를 다시
객체로 변환하는 과정을 '역직렬화'라고 합니다
