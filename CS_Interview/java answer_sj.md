# JAVA

### [Q] 자바의 특징
[A] 
Java는 객체지향 프로그래밍 언어입니다.
기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다. Garbage Collector를 통한 자동적인 메모리 관리가 가능하고 JVM 을 통해 운영체제에 독립적입니다.
<br>

### [Q] JAVA의 장단점 
[A] 
우선 장점은
JVM(자바가상머신) 위에서 작동하기 때문에 운영체제에 독립적입니다.
또한 가비지컬렉터를 통해 자동적인 메모리 관리가 가능합니다.

다음으로 단점은
JVM 위에서 작동하기 때문에 실행 속도가 상대적으로 느립니다.
또한 다중 상속이나 타입에 엄격하며, 제약이 많습니다.
<br>

### [Q] JVM이란 (Java Virtual Machine)
[A] 
JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해줍니다.

<br>

### [Q] 가비지컬렉션
[A] 
가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.
<br>

### [Q] 자바 메모리 구조
[A] 
자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.
메소드 영역은 전역변수와 static변수를 저장하며, 메소드 영역은 프로그램의 시작부터 종료까지 메모리에 남아있습니다.
스택영역은 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제됩니다. LIFO(후입선출) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워집니다.
힙 영역은 new 키워드로 생성되는 객체, 배열 등이 힙 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어집니다.
<br>

### [Q] 자바 어플리케이션 실행과정
[A] 

<br>

### [Q] 기본형과 참조형
[A] 

<br>

### [Q] ‘==’과 ‘equals’의 차이
[A]  
"=="는 주로 값을 비교하고, 두 값이 정확하게 같은지에 대한 여부를 확인합니다. 예를 들어, 두 숫자나 문자열의 내용을 비교할 때 사용됩니다.
"equals"는 객체의 동등성을 비교할 때 사용됩니다. 객체가 동일한 내용을 가지고 있는지 확인할 때 주로 사용됩니다.

<br>

### [Q] 객체란, 클래스, 메서드, 변수
[A] 
- 클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
- 객체는 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
여기서 상태는 필드, 행동은 메소드라고 표현합니다.
객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.
<br>

### [Q] 생성자 
[A] 
생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다.
명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.
<br>


### [Q] final 키워드 VS 상수
[A] 
클래스나 변수를 정의할 때 final 키워드를 사용할 수 있습니다.

final을 붙이게 되면 그 값은 변하지 않게됩니다.

<br>

### [Q] 지역 변수 VS 전역 변수 
[A] 

<br>

### [Q] static과 instance 차이
[A] 

<br>

### [Q] Java의 main 메서드가 static인 이유
[A] 

<br>

### [Q] 컬렉션 프레임워크
[A] 
다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.
자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재합니다.
<br>

### [Q] List, Set, Map
[A] 
List는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용합니다. 대표적인 구현체로는 ArrayList가 있습니다.

Set은 순서가 없는 데이터의 집합이며, 데이터의 중복을 허용하지 않습니다. 대표적인 구현체로는 HashSet이 있습니다.

Map은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없습니다.


### [Q] 배열 VS 리스트
[A] 
배열 크기가 고정적이나, 리스트는 크기가 가변적입니다.
배열과 달리 리스트는 빈 공간을 허용하지 않기 때문에 메모리의 낭비가 없습니다.
<br>

### [Q] Array VS ArrayList VS LinkedList
[A] 


<br>

### [Q] Generic
[A] 
제너릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미입니다.
제너릭을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어서 에러를 사전에 방지할 수 있습니다.
<br>


### [Q] String VS StringBuffer VS StringBuilder
[A] 
String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가집니다.
String 을 사용하여 문자열 추가나 수정, 삭제 등의 연산이 많이 발생하는 경우에는 메모리 부족으로 성능이 안 좋아집니다.
이를 해결하기 위해 가변성을 갖는 StringBuffer와 StringBuilder 클래스를 사용해 .append()나 .delete() 등의 api 를 이용해 동일 객체 내에서 문자열을 변경 할 수 있습니다.
그리고,
StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하고,
StringBuilder는 동기화를 지원하지 않기 떄문에 싱글 쓰레드 환경에서 주로 사용합니다.
<br>


### [Q] 객체지향 언어/객체지향 프로그래밍이란 ( OOP : Object Oriented Programming)
[A]  
객체 지향 프로그래밍은 프로그램 구현할 때 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의해서 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말합니다.
즉, 기능이 아닌 객체가 중심이고 "누가 어떤 일을 할 것인가?"가 핵심입니다.
특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용을 통해 확장 및 유지보수가 용이합니다.

<br>

### [Q] 객체지향 설계원칙
[A] 
SRP은 단일 책임 원칙으로 한 클래스는 하나의 책임만 가져야 합니다.
OCP는 개방-폐쇄 원칙으로 확장에는 열려있고, 수정에는 닫혀있어야 합니다.
LSP는 리스코프 치환 원칙으로 하위 타입은 항상 상위 타입을 대체 할 수 있어야 합니다.
ISP는 인터페이스 분리 원칙으로 인터페이스 내에 메소드는 최소한 일수록 좋습니다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다는 것입니다.) 
DIP는 의존관계 역전 원칙으로 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺는 것입니다. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)입니다.
<br>

### [Q] 캡슐화
[A] 
객체의 속성과 메서드를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추는 것입니다. 객체를 접근 제한자를 통해 권한이 있는 객체에서만 접근할 수 있도록 해줍니다.
<br>

### [Q] 접근제한자
[A] 
접근 제한자에는 총 4가지 종류가 있습니다.
접근 제한이 없는 public은 같은 프로젝트 내 어디서든 사용 가능합니다.
protected는 해당 패키지와 다른 패키지에서 상속받은 자식 클래스에서 접근이 가능합니다.
default는 해당 패키지 내에서만 접근이 가능하고, 
private는 해당 클래스에서만 접근 가능합니다.
<br>

### [Q] private 메서드 접근방법 
[A] 
getter, setter 를 사용하여 private으로 선언된 변수를 get이나 set으로 시작되는 public 변수로 재 선언해서 사용할 수 있습니다.
<br>

### [Q] Inner Class
[A] 
내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있습니다.
또한, 서로 관련 있는 클래스를 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
마지막으로, 외부에서는 내부 클래스에 접근할 수 없기 때문에 코드의 보안성을 높일 수 있습니다.
<br>

### [Q] 상속
[A] 
OOP 4대 특징 중 하나로써, **부모의 것을 물려받아 내 것처럼 사용하는 개념입니다.**
하지만 부모님이 상속해 주겠다는 것만 받을 수 있는 것처럼 접근제한자에서 private 로 선언된 멤버는 상속을 받을 수 없습니다. extends 라는 키워드를 사용하고, 상속 받게되면 부모 클래스 호출 없이 해당 메서드를 사용할 수 있습니다. 
<br>

### [Q] 다형성
[A] 
다형성은 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말합니다.
<br>

### [Q] 오버로딩 VS 오버라이딩의 차이점
[A] 
우선 둘 다 다형성을 지원하는데 사용됩니다.
그 중, 오버라이딩은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,
오버로딩은 매개변수의 개수나 타입을 다르게 해서 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다.

<br>

### [Q] 추상화
[A] 
공통되는 특성을 도출하고, 불필요한 특성을 제거해서 개념이나 객체를 단순화 시키는 것입니다.
이를 통해서 공유할 수 있는 규격을 만들어낼 수 있습니다.

예를 들어 게임 개발 시에 다양한 캐릭터가 있을 수 있지만 추상화를 통해 모든 캐릭터가 공통으로 가져야 하는 점프같은 행동을 정의하는 규격을 만들 수 있습니다.
<br>

### [Q] 인터페이스란
[A] 
인터페이스는 공동의 작업을 할 때 공통된 규격을 잡아주는 역할입니다.
예를 들자면, 키보드에는 기능이 많지만 단순히 누르기만 하면 되는 장치인 것과 같습니다.
또한 인터페이스는 객체화가 불가능해서 implements 를 사용하고, 인터페이스 안의 메서드는 무조건 추상메서드로 알고있습니다.

<br>

### [Q] 추상 클래스 VS 인터페이스
[A]  
추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.

추상클래스는 구체적인 로직이나 상태를 가질 수 있는 반면, 인터페이스는 구체적인 로직이나 상태를 가질 수 없습니다.
그리고 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능합니다. 

<br>

### [Q] Error와 Exception의 차이
[A]  
에러는 실행 중 일어날 수 있는 치명적 오류를 말합니다. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료됩니다.
반면, 예외는 에러보다 비교적 경미한 오류이고, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다.
<br>

### [Q] Exception 처리 방법
[A]  
try-catch를 사용해 예외가 발생한 메소드 내에서 직접 처리하는 방법과
throws 를 사용해 예외가 발생한 메소드를 호출한 곳으로 예외를 넘겨주는 방법이 있습니다.
(질문!!!!)사용자 정의 예외를 생성하여 처리하는 방법이 있다.
<br>


### [Q] 동기 VS 비동기 방식
[A]  
동기방식은 설계가 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있습니다.
비동기방식 은 동기보다는 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있어서 자원을 효율적으로 사용할 수 있는 장점이 있습니다.

예를 들어, 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 동기와 달리 비동기는 서버에 데이터를 요청한 이후 응답될 때까지 대기하지 않고 즉시 다음 테스크를 계속해 수행할 수 있습니다.
<br>

### [Q] synchronized
[A]  
여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
<br>

### [Q] 프로세스, 스레드
[A]  
프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않습니다. 또한, 프로세스는 최소 1개의 쓰레드를 가지고 있습니다.

쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
프로세스 내에서 Stack만 따로 할당 받고, 서로 다른 쓰레드의 메모리 영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 

<br>

### [Q] 멀티 스레드의 장점과 단점
[A] 
멀티 쓰레드는 적은 메모리 공간을 차지하고 문맥 전환이 빠르다(질문)는 장점이 있지만
하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.
<br>

### [Q] JDBC Java Database Connectivity
[A]  
JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미합니다.
<br>

### [Q] API Applictation Programming Interface
[A]  
다른 프로그램에 이용할 수 있도록 제공되는 클래스와 인터페이스입니다.
<br>

### [Q] RestfulAPI
[A] 
RESTfulAPI는 REST의 설계 규칙을 잘 지켜서 설계된 API를 말합니다.


<br>

### [Q] Get VS Post 방식
[A] 
GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다.
GET 방식은 URL에 데이터가 노출이 되기 때문에 보안적으로 좋지 않습니다.

POST 방식은 데이터를 추가나 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가해서 전송하는 방식입니다.
POST 방식은 URL에 데이터가 노출되지 않기 때문에 GET 보다는 안전한 편입니다.
대신 전송 속도가 GET 방식보다 느립니다.

<br>

### [Q] Cookie VS Session
[A] 
쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요할 때 그 정보를 참조하거나 재사용할 수 있습니다.
세션은 일정 시간동안 같은 사용자로부터 들어오는 어떤 요구들을 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 합니다.
<br>

### [Q] jsp, servlet
[A] 
Servlet은 컨테이너가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것이고,
JSP(Java Server Page)는 html기반에 JAVA코드를 블록화하여 삽입한 것입니다.
<br>

### [Q] model1 과 model2 의 차이점
[A] 
Model1은 Jsp가 뷰와 컨트롤러의 역할을 모두 감당합니다.
Jsp가 두 역할을 모두 수행할 때는 소스가 복잡해지기 때문에 유지보수가 힘들어집니다.

Model2는 Model1 의 단점을 보완할 수 있는데요,
Model1 과 달리 컨트롤러의 역할은 서블릿에서 담당하고 응답처리는 JSP에서 구현됩니다. 개발속도는 비교적 느려지지만 확장과 유지보수가 수월해집니다. 
<br>

### [Q] 어노테이션
[A] 
인터페이스를 기반으로 한 문법으로 주석, 자바코드에 주석을 달아 특별한 의미를 부여한 것입니다.
<br>

### [Q] 직렬화
[A] 
시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 '역직렬화'라고 합니다.

<br>
